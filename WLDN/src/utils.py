from rdkit import Chem
import tensorflow as tf
import tensorflow.keras.backend as K
import numpy as np
from src.eval_by_smiles import edit_mol_smiles
from graph_utils.ioutils_direct import bo_to_index, hydro_to_index, formal_to_index

def set_map(smi, sanitize=True):
    '''
    Function for setting the atom map for SMILES

    args:
        smi (str): Reactant SMILES
        sanitize (bool): Whether to perform RDKit sanitization/canonicalization

    output:
        smiles (str): Atom mapped SMILES
    '''

    #TODO figure out sanitation. converting back and forth gives more similar results to rexgen
    if sanitize:
        m = Chem.MolFromSmiles(Chem.MolToSmiles(Chem.MolFromSmiles(smi, sanitize=False)), sanitize=False)
    else:
        m = Chem.MolFromSmiles(smi, sanitize=False)
    if any(not a.HasProp('molAtomMapNumber') for a in m.GetAtoms()):
        mapnum = 1
        for a in m.GetAtoms():
            a.SetIntProp('molAtomMapNumber', mapnum)
            mapnum += 1
    return Chem.MolToSmiles(m), m.GetNumAtoms()


def topk_numpy(scores, bond_labels, nk=80):
    bmask = K.cast(K.equal(bond_labels, INVALID_BOND), dtype='float32') * 10000
    topk_scores, topk = tf.nn.top_k(scores - bmask, k=nk)
    topk_scores = topk_scores.numpy() #make it easier, don't use tf eager for basic math

    return topk.numpy()


def enumerate_outcomes(rsmi, conf, scores, top_n=100):
        """
        Function to enumerate the outcomes based on the edit scores generated by WLNCandidateRanker model

        args:
            rsmi (str): reactant SMILES
            conf (list of tuples):
            scores (array): Numpy array of candidate scores shape=(1, cutoff)
            top_n (int): How many outcomes to enumerate

        """
        scores = K.squeeze(scores, axis=0)
        tk = tf.minimum(top_n, tf.shape(scores)[0])
        _,topk = tf.nn.top_k(scores, k=tk)
        topk = topk.numpy()

        idxfunc = lambda x:x.GetIntProp('molAtomMapNumber') - 1

        # Don't waste predictions on bond changes that aren't actually changes
        rmol = Chem.MolFromSmiles(rsmi, sanitize=False)
        rbonds = {}
        for bond in rmol.GetBonds():
            a1 = idxfunc(bond.GetBeginAtom())
            a2 = idxfunc(bond.GetEndAtom())
            t = bond.GetBondTypeAsDouble()
            a1,a2 = min(a1,a2),max(a1,a2)
            rbonds[(a1,a2)] = t


        cand_smiles = []; cand_scores = []; predicted_edits = [];
        for idx in topk:
            cbonds = []
            # Define edits from prediction
            for x,y,t,v,l in conf[idx]:
                if l == 'b':
                    if ((x,y) not in rbonds and t > 0) or ((x,y) in rbonds and rbonds[(x,y)] != t):
                       cbonds.append((x, y, float(bo_to_index[t]), l))
                elif l == 'h':
                    cbonds.append((x, y, hydro_to_index[t], l))
                elif l == 'f':
                    cbonds.append((x, y, formal_to_index[t], l))
            try:
                # print(conf[idx], cbonds)
                pred_smiles = edit_mol_smiles(rmol, cbonds)
                if pred_smiles:  # If molecule is invalid, pred_smiles will be None
                    # print(pred_smiles, '\n')
                    if pred_smiles in cand_smiles:
                        continue
                    else:
                        cand_smiles.append(pred_smiles)
                        cand_scores.append(scores[idx])
                        predicted_edits.append(cbonds)
                else:
                    continue
            except Exception as e:
                # print(e)
                # print('This is error!, ', cbonds)
                continue

        cand_probs = K.softmax(tf.convert_to_tensor(np.array(cand_scores)))

        outcomes = []

        for i in range(min(len(cand_smiles), top_n)):
            # print(cand_smiles[i], predicted_edits[i], cand_probs[i].numpy())
            outcomes.append({
                'rank': i + 1,
                'smiles': cand_smiles[i],
                'predicted_edits': predicted_edits[i],
                'score': cand_scores[i].numpy(),
                'prob': cand_probs[i].numpy(),
            })

        return outcomes
